;; Simple Regex Tamarin Highlighting (02_simple_regex)
;; Includes basic regex patterns, but no apostrophes or quantifiers

;; Keywords
[
  "theory"
  "begin"
  "end"
  "rule"
  "lemma"
  "builtins"
  "functions"
  "equations"
  "predicates"
  "restriction"
  "axiom"
  "diffLemma"
  "let"
  "in"
  "new"
  "out"
  "if"
  "then"
  "else"
  "event"
  "insert"
  "delete"
  "lookup"
  "as"
  "lock"
  "unlock"
  "tactic"
  "All"
  "Ex"
  "∀"
  "∃"
] @keyword

;; Comments
(multi_comment) @comment
(single_comment) @comment

;; Structure
(theory
  theory_name: (ident) @type)

;; Built-ins
(built_in) @type.builtin
(built_ins) @keyword.module
(functions) @keyword.module

;; Functions
(function_untyped) @function
(function_typed) @function
(nullary_fun) @function

;; Simple regex for built-in functions
((ident) @function.builtin
  (#match? @function.builtin "^senc$"))

((ident) @function.builtin
  (#match? @function.builtin "^sdec$"))

((ident) @function.builtin
  (#match? @function.builtin "^mac$"))

((ident) @function.builtin
  (#match? @function.builtin "^kdf$"))

((ident) @function.builtin
  (#match? @function.builtin "^pk$"))

((ident) @function.builtin
  (#match? @function.builtin "^h$"))

;; Simple regex for macro calls (uppercase identifiers)
((ident) @function.macro.call
  (#match? @function.macro.call "^[A-Z][A-Z0-9_]*$"))

;; Simple regex patterns for tactic values
((ident) @keyword.tactic.value
  (#match? @keyword.tactic.value "^direct$"))

((ident) @keyword.tactic.value
  (#match? @keyword.tactic.value "^sorry$"))

((ident) @keyword.tactic.value
  (#match? @keyword.tactic.value "^induction$"))

;; Facts
(linear_fact) @fact.linear
(persistent_fact) @fact.persistent
(action_fact) @fact.action

;; Built-in facts
((linear_fact
  (ident) @fact.builtin)
  (#match? @fact.builtin "^Fr$"))

((linear_fact
  (ident) @fact.builtin)
  (#match? @fact.builtin "^In$"))

((linear_fact
  (ident) @fact.builtin)
  (#match? @fact.builtin "^Out$"))

((linear_fact
  (ident) @fact.builtin)
  (#match? @fact.builtin "^K$"))

;; Variable types identified by node type
(pub_var) @variable.public
(fresh_var) @variable.fresh
(temporal_var) @variable.temporal
(msg_var_or_nullary_fun) @variable.message
(nat_var) @variable.number

;; Simple regex for variables (no apostrophes)
((ident) @variable.public
  (#match? @variable.public "^\\$[a-zA-Z][a-zA-Z0-9_]*$"))

((ident) @variable.fresh
  (#match? @variable.fresh "^~[a-zA-Z][a-zA-Z0-9_]*$"))

((ident) @variable.temporal
  (#match? @variable.temporal "^#[a-zA-Z][a-zA-Z0-9_]*$"))

((ident) @variable.message
  (#match? @variable.message "^[a-z][a-zA-Z0-9_]*$"))

;; Constants and numbers
(natural) @number
(param) @string
(hexcolor) @constant
(pub_name) @public.constant
(fresh_name) @constant.string

;; Punctuation and operators
["(" ")" "[" "]" "<" ">"] @punctuation.bracket
["-->" "-->"] @punctuation.special
["," "." ":" ";"] @punctuation.delimiter
"^" @operator.exponentiation

;; Rule structure
(premise) @structure
(conclusion) @structure
(quantified_formula) @structure
(nested_formula) @structure

;; Logical operators
(imp) @operator.logical
(negation) @operator.logical
(conjunction) @operator.logical
(disjunction) @operator.logical
(iff) @operator.logical

;; Rule parts
(simple_rule 
  rule_identifier: (ident) @function.rule)
(lemma 
  lemma_identifier: (ident) @function.rule)
(restriction
  restriction_identifier: (ident) @function.rule) 