;; OR Operators Support Tamarin Highlighting (05_or_operators)
;; Adds more complex OR operations in regex patterns

;; Keywords
[
  "theory"
  "begin"
  "end"
  "rule"
  "lemma"
  "builtins"
  "functions"
  "equations"
  "predicates"
  "restriction"
  "axiom"
  "diffLemma"
  "let"
  "in"
  "new"
  "out"
  "if"
  "then"
  "else"
  "event"
  "insert"
  "delete"
  "lookup"
  "as"
  "lock"
  "unlock"
  "tactic"
  "All"
  "Ex"
  "∀"
  "∃"
] @keyword

;; Comments
(multi_comment) @comment
(single_comment) @comment

;; Structure
(theory
  theory_name: (ident) @type)

;; Built-ins
(built_in) @type.builtin
(built_ins) @keyword.module
(functions) @keyword.module

;; Functions
(function_untyped) @function
(function_typed) @function
(nullary_fun) @function

;; Simple regex for built-in functions - with OR
((ident) @function.builtin
  (#match? @function.builtin "^(senc|sdec|mac|kdf|pk|h)$"))

;; Macro keyword with OR
((ident) @keyword.macro
  (#match? @keyword.macro "^(macro|macros)$"))

;; Simple regex for macro calls (uppercase identifiers)
((ident) @function.macro.call
  (#match? @function.macro.call "^[A-Z][A-Z0-9_]*$"))

;; Simple regex patterns for tactic values - with OR
((ident) @keyword.tactic.value
  (#match? @keyword.tactic.value "^(direct|sorry|induction)$"))

;; Facts
(linear_fact) @fact.linear
(persistent_fact) @fact.persistent
(action_fact) @fact.action

;; Built-in facts - with OR
((linear_fact
  (ident) @fact.builtin)
  (#match? @fact.builtin "^(Fr|In|Out|K)$"))

;; Exclude built-in facts from macro calls
((ident) @function.macro.call
  (#match? @function.macro.call "^[A-Z][A-Z0-9_]*$")
  (#not-match? @function.macro.call "^(Fr|In|Out|K)$"))

;; Variable types identified by node type
(pub_var) @variable.public
(fresh_var) @variable.fresh
(temporal_var) @variable.temporal
(msg_var_or_nullary_fun) @variable.message
(nat_var) @variable.number

;; Variables with quantifiers for apostrophes
((ident) @variable.public
  (#match? @variable.public "^\\$[a-zA-Z][a-zA-Z0-9_]*'?$"))

((ident) @variable.fresh
  (#match? @variable.fresh "^~[a-zA-Z][a-zA-Z0-9_]*'?$"))

((ident) @variable.temporal
  (#match? @variable.temporal "^#[a-zA-Z][a-zA-Z0-9_]*'?$"))

;; Complex pattern for message variables
((ident) @variable.message
  (#match? @variable.message "^[a-z][a-zA-Z0-9_]*'?$")
  (#not-match? @variable.message "^[A-Z][A-Z0-9_]*$")
  (#not-match? @variable.message "^(Fr|In|Out|K)$"))

;; Type annotations with OR operator
((ident) @variable.message
  (#not-match? @variable.message ":pub$|:fresh$|:temporal$|:msg$"))

;; But also add specific type annotations
((ident) @variable.public
  (#match? @variable.public "^[a-zA-Z][a-zA-Z0-9_]*:pub$"))

((ident) @variable.fresh
  (#match? @variable.fresh "^[a-zA-Z][a-zA-Z0-9_]*:fresh$"))

((ident) @variable.temporal
  (#match? @variable.temporal "^[a-zA-Z][a-zA-Z0-9_]*:temporal$"))

((ident) @variable.message
  (#match? @variable.message "^[a-zA-Z][a-zA-Z0-9_]*:msg$"))

;; Constants and numbers
(natural) @number
(param) @string
(hexcolor) @constant
(pub_name) @public.constant
(fresh_name) @constant.string

;; String literals with single quotes
((ident) @public.constant
  (#match? @public.constant "^'[^']*'$"))

;; Punctuation and operators
["(" ")" "[" "]" "<" ">"] @punctuation.bracket
["-->" "-->"] @punctuation.special
["," "." ":" ";"] @punctuation.delimiter
"^" @operator.exponentiation

;; Rule structure
(premise) @structure
(conclusion) @structure
(quantified_formula) @structure
(nested_formula) @structure

;; Logical operators
(imp) @operator.logical
(negation) @operator.logical
(conjunction) @operator.logical
(disjunction) @operator.logical
(iff) @operator.logical

;; Rule parts
(simple_rule 
  rule_identifier: (ident) @function.rule)
(lemma 
  lemma_identifier: (ident) @function.rule)
(restriction
  restriction_identifier: (ident) @function.rule) 